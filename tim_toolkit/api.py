"""
Truth-in-Motion (TIM) Engine - API Module
Main interface for the TIM compilation engine.
"""

from typing import Dict, Any, Optional
from .diagnostics import DiagnosticValidator, DiagnosticLogger
from .classifier import ExpectationBreakClassifier
from .validator import TIMValidator\nfrom .compiler import TIMCompiler


class TIMEngine:
    \"\"\"Main TIM Engine interface.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize TIM Engine with all sub-components.\"\"\"\n        self.compiler = TIMCompiler()\n        self.classifier = ExpectationBreakClassifier()\n        self.validator = TIMValidator()\n        self.logger = DiagnosticLogger()\n    \n    def compile(self, payload: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"\n        Main compilation endpoint.\n        \n        Args:\n            payload: {\n                \"content\": str,              # Joke or micro-truth\n                \"boundary_insight\": str,    # The deeper pattern\n                \"constraints\": {\n                    \"non_coercion\": bool,   # Enforce non-coercion\n                    \"max_length\": int,      # Optional length limit\n                    \"style\": str            # Optional: \"narrative\", \"lyrical\", \"philosophical\"\n                }\n            }\n        \n        Returns:\n            {\n                \"status\": \"success\" | \"unstable\" | \"failed\",\n                \"song\": str,\n                \"diagnostics\": {...},\n                \"metadata\": {...}\n            }\n        \"\"\"\n        # Validate payload\n        if \"content\" not in payload or \"boundary_insight\" not in payload:\n            return {\n                \"status\": \"failed\",\n                \"error\": \"Missing required fields: content, boundary_insight\"\n            }\n        \n        content = payload[\"content\"]\n        insight = payload[\"boundary_insight\"]\n        constraints = payload.get(\"constraints\", {\"non_coercion\": True})\n        \n        # Compile\n        result = self.compiler.compile_joke_to_song(content, insight)\n        \n        # Apply constraints\n        if constraints.get(\"max_length\"):\n            if len(result.get(\"song\", \"\")) > constraints[\"max_length\"]:\n                result[\"status\"] = \"unstable\"\n                result[\"warning\"] = f\"Song exceeds max_length of {constraints['max_length']}\"\n        \n        return result\n    \n    def analyze(self, content: str) -> Dict[str, Any]:\n        \"\"\"\n        Analyze content for compilation readiness.\n        \n        Returns analysis of breaks, coercion, and expansion potential.\n        \"\"\"\n        breaks = self.classifier.detect_breaks(content)\n        is_valid, violations = self.validator.validate(content)\n        expansion_ratio = self.compiler.estimate_expansion_ratio(content)\n        \n        return {\n            \"content_length\": len(content),\n            \"word_count\": len(content.split()),\n            \"break_count\": len(breaks),\n            \"break_types\": list(set(b.break_type for b in breaks)),\n            \"is_non_coercive\": is_valid,\n            \"coercion_violations\": violations,\n            \"expansion_ratio\": expansion_ratio,\n            \"content_type\": self.classifier.classify_content_type(content),\n            \"core_insight\": self.classifier.extract_core_insight(content),\n            \"surprise_density\": self.classifier.calculate_surprise_density(content),\n            \"invitation_score\": self.validator.calculate_invitation_score(content),\n            \"coercion_score\": self.validator.calculate_coercion_score(content),\n        }\n    \n    def validate_non_coercion(self, content: str) -> Dict[str, Any]:\n        \"\"\"\n        Validate that content is non-coercive.\n        \n        Returns detailed validation report with suggestions.\n        \"\"\"\n        is_valid, violations = self.validator.validate(content)\n        suggestion = self.validator.suggest_reframe(content)\n        \n        return {\n            \"is_valid\": is_valid,\n            \"violations\": violations,\n            \"suggestion\": suggestion,\n            \"invitation_score\": self.validator.calculate_invitation_score(content),\n            \"coercion_score\": self.validator.calculate_coercion_score(content),\n        }\n    \n    def detect_expectation_breaks(self, content: str) -> Dict[str, Any]:\n        \"\"\"\n        Detect and report expectation breaks in content.\n        \n        Returns detailed break analysis.\n        \"\"\"\n        breaks = self.classifier.detect_breaks(content)\n        scores = self.classifier.score_expectation_breaks(content)\n        \n        return {\n            \"break_count\": len(breaks),\n            \"breaks\": [\n                {\n                    \"type\": b.break_type,\n                    \"position\": b.position,\n                    \"content\": b.content,\n                    \"confidence\": b.confidence,\n                    \"explanation\": b.explanation\n                }\n                for b in breaks\n            ],\n            \"scores\": scores,\n            \"content_type\": self.classifier.classify_content_type(content),\n        }\n    \n    def batch_compile(self, payloads: list) -> list:\n        \"\"\"\n        Compile multiple jokes in batch.\n        \n        Args:\n            payloads: List of compilation payloads\n        \n        Returns:\n            List of compilation results\n        \"\"\"\n        results = []\n        for payload in payloads:\n            result = self.compile(payload)\n            results.append(result)\n        return results\n\n\n# Global engine instance\n_engine = None\n\n\ndef get_engine() -> TIMEngine:\n    \"\"\"Get or create global TIM Engine instance.\"\"\"\n    global _engine\n    if _engine is None:\n        _engine = TIMEngine()\n    return _engine\n\n\ndef compile_endpoint(payload: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Main compilation endpoint.\n    \n    Usage:\n        result = compile_endpoint({\n            \"content\": \"Why did the map stop arguing?\",\n            \"boundary_insight\": \"Maps are tools, not truth.\",\n            \"constraints\": {\"non_coercion\": True}\n        })\n    \"\"\"\n    engine = get_engine()\n    return engine.compile(payload)\n\n\ndef analyze_endpoint(content: str) -> Dict[str, Any]:\n    \"\"\"\n    Analyze content for compilation readiness.\n    \n    Usage:\n        analysis = analyze_endpoint(\"Why did the river refuse to argue?\")\n    \"\"\"\n    engine = get_engine()\n    return engine.analyze(content)\n\n\ndef validate_endpoint(content: str) -> Dict[str, Any]:\n    \"\"\"\n    Validate non-coercion.\n    \n    Usage:\n        validation = validate_endpoint(\"You must believe this...\")\n    \"\"\"\n    engine = get_engine()\n    return engine.validate_non_coercion(content)\n\n\ndef breaks_endpoint(content: str) -> Dict[str, Any]:\n    \"\"\"\n    Detect expectation breaks.\n    \n    Usage:\n        breaks = breaks_endpoint(\"Why did the map stop arguing?\")\n    \"\"\"\n    engine = get_engine()\n    return engine.detect_expectation_breaks(content)\n\n\n# Final Invariant\n\"\"\"\nTruth = coherent relationship in motion.\n\nIf it coerces, it fails.\nIf it doesn't move, it doesn't teach.\n\"\"\"\n

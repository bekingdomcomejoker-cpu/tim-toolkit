"""
Truth-in-Motion (TIM) Engine - Compiler Module
Expands compressed micro-truths (jokes) into temporal forms (songs).
"""

from typing import List, Dict, Optional
from .diagnostics import DiagnosticReport, DiagnosticValidator, Diagnostic
from .classifier import ExpectationBreakClassifier
from .validator import TIMValidator


class TIMCompiler:
    \"\"\"\n    Compiles micro-truths (jokes) into macro-truths (songs).\n    \n    Compression ratios:\n    - Joke (micro-truth): 1:100 (highly compressed)\n    - Song (macro-truth): 1:1,000 (fully unfolded)\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize compiler with sub-engines.\"\"\"\n        self.classifier = ExpectationBreakClassifier()\n        self.validator = TIMValidator()\n    \n    def compile_joke_to_song(self, joke: str, boundary_insight: str) -> Dict:\n        \"\"\"\n        Compile a joke into a song.\n        \n        Args:\n            joke: The micro-truth (compressed insight)\n            boundary_insight: The deeper pattern being revealed\n        \n        Returns:\n            Dict with song, diagnostics, and metadata\n        \"\"\"\n        # Validate non-coercion\n        is_valid, violations = self.validator.validate(joke)\n        \n        if not is_valid:\n            return {\n                \"status\": \"failed\",\n                \"error\": \"Joke contains coercive language\",\n                \"violations\": violations,\n                \"diagnostics\": [Diagnostic.COERCION_DETECTED.value]\n            }\n        \n        # Detect expectation breaks\n        breaks = self.classifier.detect_breaks(joke)\n        \n        if not breaks:\n            return {\n                \"status\": \"unstable\",\n                \"error\": \"No expectation breaks detected in joke\",\n                \"diagnostics\": [Diagnostic.UNDER_COMPRESSION.value]\n            }\n        \n        # Generate song verses\n        verses = self._generate_verses(joke, boundary_insight, breaks)\n        \n        # Generate chorus\n        chorus = self._generate_chorus(boundary_insight)\n        \n        # Generate bridge\n        bridge = self._generate_bridge(breaks, boundary_insight)\n        \n        # Assemble song\n        song = self._assemble_song(verses, chorus, bridge)\n        \n        # Calculate metrics\n        compression_ratio = len(song) / len(joke) if joke else 1.0\n        coherence_score = self._calculate_coherence(song, boundary_insight)\n        \n        # Build diagnostic report\n        report = DiagnosticValidator.build_report(\n            compression_ratio=compression_ratio,\n            coherence_score=coherence_score,\n            breaks_detected=len(breaks),\n            coercion_detected=False,\n            semantic_surprise=len(breaks) > 0,\n            metadata={\n                \"break_types\": list(set(b.break_type for b in breaks)),\n                \"invitation_score\": self.validator.calculate_invitation_score(song)\n            }\n        )\n        \n        return {\n            \"status\": report.status.value,\n            \"song\": song,\n            \"verses\": verses,\n            \"chorus\": chorus,\n            \"bridge\": bridge,\n            \"diagnostics\": report.to_dict(),\n            \"compression_ratio\": compression_ratio,\n            \"coherence_score\": coherence_score,\n            \"breaks_detected\": len(breaks)\n        }\n    \n    def _generate_verses(self, joke: str, insight: str, breaks: List) -> List[str]:\n        \"\"\"\n        Generate song verses from joke and breaks.\n        \n        Verses expand the compressed joke into narrative form.\n        \"\"\"\n        verses = []\n        \n        # Verse 1: Setup (establish the expectation)\n        verse1 = f\"\"\"Verse 1:\nThe question posed, the path laid clear,\nExpectation whispered in the ear,\n{joke.split('?')[0] if '?' in joke else joke[:50]}...\nThe answer seemed so very near.\"\"\"\n        verses.append(verse1)\n        \n        # Verse 2: Expectation Break (the surprise)\n        if breaks:\n            primary_break = breaks[0]\n            verse2 = f\"\"\"Verse 2:\nBut then a turn, a twist of fate,\nThe answer came, it would not wait,\n{primary_break.content}\nThe insight opened up the gate.\"\"\"\n            verses.append(verse2)\n        \n        # Verse 3: Boundary Insight (the deeper meaning)\n        verse3 = f\"\"\"Verse 3:\nFor in this truth, a pattern shows,\nWhere understanding deeply flows,\n{insight}\nThis is the wisdom that it knows.\"\"\"\n        verses.append(verse3)\n        \n        # Verse 4: Reflection (what it means)\n        verse4 = f\"\"\"Verse 4:\nSo when you hear this tale once more,\nRemember what lies at its core,\nThe joke was just the outer shell,\nThe truth within is what to tell.\"\"\"\n        verses.append(verse4)\n        \n        return verses\n    \n    def _generate_chorus(self, insight: str) -> str:\n        \"\"\"\n        Generate chorus that captures the core insight.\n        \n        Chorus is repeated, so it must be memorable and invitational.\n        \"\"\"\n        chorus = f\"\"\"Chorus:\nTruth moves, it never stays still,\nIt breaks what we thought we will,\n{insight}\nThis is the deeper thrill.\"\"\"\n        \n        return chorus\n    \n    def _generate_bridge(self, breaks: List, insight: str) -> str:\n        \"\"\"\n        Generate bridge that connects joke to deeper meaning.\n        \n        Bridge is where the transformation happens.\n        \"\"\"\n        bridge_type = breaks[0].break_type if breaks else \"paradox\"\n        \n        bridge = f\"\"\"Bridge:\nThe {bridge_type} was the key,\nThat set the hidden meaning free,\nFrom compressed joke to flowing song,\nThe truth was there all along.\"\"\"\n        \n        return bridge\n    \n    def _assemble_song(self, verses: List[str], chorus: str, bridge: str) -> str:\n        \"\"\"\n        Assemble verses, chorus, and bridge into complete song.\n        \"\"\"\n        song_parts = [\n            verses[0],\n            chorus,\n            verses[1] if len(verses) > 1 else \"\",\n            chorus,\n            verses[2] if len(verses) > 2 else \"\",\n            bridge,\n            chorus,\n            verses[3] if len(verses) > 3 else \"\",\n            \"Outro:\\nThe truth keeps moving, ever on,\\nFrom dusk until the breaking dawn.\"\n        ]\n        \n        return \"\\n\\n\".join([p for p in song_parts if p])\n    \n    def _calculate_coherence(self, song: str, insight: str) -> float:\n        \"\"\"\n        Calculate coherence score (0.0 to 1.0).\n        \n        Measures how well the song maintains the boundary insight.\n        \"\"\"\n        # Check if insight appears in song\n        if insight.lower() in song.lower():\n            base_score = 0.8\n        else:\n            base_score = 0.5\n        \n        # Check for narrative flow\n        verse_count = song.count(\"Verse\")\n        chorus_count = song.count(\"Chorus\")\n        \n        if verse_count >= 3 and chorus_count >= 2:\n            base_score += 0.15\n        \n        # Check for coherence violations\n        violations = self.validator._check_coherence(song)\n        if violations:\n            base_score -= len(violations) * 0.1\n        \n        return max(0.0, min(1.0, base_score))\n    \n    def compile_batch(self, jokes_with_insights: List[Dict]) -> List[Dict]:\n        \"\"\"\n        Compile multiple jokes into songs.\n        \n        Args:\n            jokes_with_insights: List of {\"joke\": str, \"insight\": str}\n        \n        Returns:\n            List of compiled results\n        \"\"\"\n        results = []\n        \n        for item in jokes_with_insights:\n            result = self.compile_joke_to_song(item[\"joke\"], item[\"insight\"])\n            results.append(result)\n        \n        return results\n    \n    def estimate_expansion_ratio(self, joke: str) -> float:\n        \"\"\"\n        Estimate how much a joke will expand when compiled.\n        \n        Based on joke length and break density.\n        \"\"\"\n        breaks = self.classifier.detect_breaks(joke)\n        break_count = len(breaks)\n        word_count = len(joke.split())\n        \n        # Base expansion: 10x\n        base_expansion = 10.0\n        \n        # Adjust for break density\n        break_density = (break_count / max(word_count, 1)) * 100\n        expansion_factor = 1.0 + (break_density / 10.0)\n        \n        return base_expansion * expansion_factor\n\n\n# Final Invariant\n\"\"\"\nCompilation transforms:\n- Compressed (joke) → Expanded (song)\n- Surprise → Understanding\n- Micro-truth → Macro-truth\n\nIf it coerces, it fails.\nIf it moves, it teaches.\n\"\"\"\n
